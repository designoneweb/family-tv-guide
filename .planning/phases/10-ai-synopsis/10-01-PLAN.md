---
phase: 10-ai-synopsis
plan: 01
type: execute
---

<objective>
Create server-side AI synopsis generation infrastructure with Gemini integration and Supabase caching.

Purpose: Enable spoiler-safe episode synopses generated by AI, with efficient caching to minimize API calls.
Output: Gemini client wrapper, blurb service with caching, and API route for synopsis generation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**From prior phases:**
- Episode detail page at /app/show/[id]/season/[seasonNumber]/episode/[episodeNumber]
- TMDB client pattern established in web/lib/tmdb/client.ts
- Database types include EpisodeBlurb with source field ('tmdb_truncate' | 'ai')
- episode_blurbs table already exists in Supabase

**Discovery findings:**
- SDK: @google/genai (npm package)
- Model: gemini-3-flash-preview (latest flash model)
- API key: GEMINI_API_KEY environment variable (auto-detected by SDK)
- Rate limits: Free tier is sufficient for on-demand generation

**Key files:**
@web/lib/tmdb/client.ts
@web/lib/database.types.ts
@web/app/app/show/[id]/season/[seasonNumber]/episode/[episodeNumber]/episode-client.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Gemini SDK and create client wrapper</name>
  <files>web/package.json, web/lib/gemini/client.ts</files>
  <action>
1. Install @google/genai package: npm install @google/genai
2. Create web/lib/gemini/client.ts with:
   - getGeminiClient() function that creates GoogleGenAI client
   - Check for GEMINI_API_KEY env var, return null if missing (graceful fallback)
   - generateEpisodeSynopsis(showName: string, seasonNumber: number, episodeNumber: number, episodeName: string, overview: string) function
   - Prompt should request: "Create a spoiler-free 2-3 sentence synopsis for this TV episode. Focus on setup and tone without revealing plot twists or endings."
   - Use gemini-3-flash-preview model
   - Return generated text or null on error
   - Include try-catch with console.error for debugging
  </action>
  <verify>TypeScript compiles without errors: cd web && npx tsc --noEmit</verify>
  <done>Gemini client wrapper exists with graceful fallback when API key missing</done>
</task>

<task type="auto">
  <name>Task 2: Create blurb service with Supabase caching</name>
  <files>web/lib/services/blurbs.ts</files>
  <action>
1. Create web/lib/services/blurbs.ts with:
   - getBlurb(seriesTmdbId: number, seasonNumber: number, episodeNumber: number) - fetch cached blurb
   - saveBlurb(seriesTmdbId: number, seasonNumber: number, episodeNumber: number, blurbText: string, source: 'tmdb_truncate' | 'ai') - upsert blurb
   - Use Supabase client from createServerClient pattern
   - Query episode_blurbs table by (series_tmdb_id, season_number, episode_number)
   - Return EpisodeBlurb type from database.types.ts
2. Add truncateOverview(overview: string, maxLength: number = 200) helper function:
   - Truncate at sentence boundary if possible
   - Add ellipsis if truncated
   - This provides the TMDB fallback
  </action>
  <verify>TypeScript compiles without errors: cd web && npx tsc --noEmit</verify>
  <done>Blurb service can read/write episode_blurbs table and truncate overviews</done>
</task>

<task type="auto">
  <name>Task 3: Create API route for synopsis generation</name>
  <files>web/app/api/synopsis/route.ts</files>
  <action>
1. Create POST /api/synopsis route that:
   - Accepts JSON body: { showId: number, showName: string, seasonNumber: number, episodeNumber: number, episodeName: string, overview: string }
   - First checks cache via blurbs.getBlurb()
   - If cached blurb exists, return it immediately with { blurb: string, source: 'ai' | 'tmdb_truncate', cached: true }
   - If no cache, attempt Gemini generation via generateEpisodeSynopsis()
   - If Gemini succeeds: save to cache with source='ai', return { blurb, source: 'ai', cached: false }
   - If Gemini fails (no API key or error): generate truncated TMDB overview, save with source='tmdb_truncate', return { blurb, source: 'tmdb_truncate', cached: false }
   - Return 200 for all success cases, 400 for missing required fields
2. Handle errors gracefully - never expose internal errors to client
  </action>
  <verify>cd web && npm run build succeeds without errors</verify>
  <done>POST /api/synopsis returns cached or generated synopsis with graceful fallback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd web && npm run build` succeeds without errors
- [ ] Gemini SDK installed in package.json
- [ ] web/lib/gemini/client.ts exports generateEpisodeSynopsis function
- [ ] web/lib/services/blurbs.ts exports getBlurb, saveBlurb, truncateOverview
- [ ] web/app/api/synopsis/route.ts handles POST requests
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- API route handles both Gemini success and fallback cases
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-synopsis/10-01-SUMMARY.md`
</output>
